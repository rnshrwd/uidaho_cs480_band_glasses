/* ht13.c
 * compile: gcc -O2 ht13.c -lftdi -lncurses -o ht13
 * this program transmits dmx-style rgb packets
 * modified to adjust to software PWM on the Mrfs
 * broadcasts from PC/Xbee to Mrf/Arduino
 *
 * really going to try constant broadcast this time
 * and... it flickers really badly on holds
 *
 * Benjamin Jeffery
 * University of Idaho
 * 11/11/2015
 * millisec() is copied from unicon/src/common/time.c
 * for testing purposes. Thanks Clint
 *
 * Some minor edits/cleanup by Lucas Jackson
 * University of Idaho
 * 10/27/2020
 */

#include <ftdi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <unistd.h>
#include <time.h> 
//#include <sys/times.h>
#include <curses.h>

#define DOT   100000
#define DASH  300000
#define SLOW  500000
#define DORK  150000
#define DROOL 1000000
#define DAB   50000
#define SLP   40000

//static size_t encode(const uint8_t* source, size_t size, uint8_t* destination);
static size_t getEncodedBufferSize(size_t sourceSize);
long millisec();
uint8_t sorc[108] = { };
uint8_t dest[108] = { };

uint8_t convert_red(int);
uint8_t convert_green(int);
uint8_t convert_blue(int);

uint8_t create_patterns(char *glasses_information, uint8_t***, int**, int z); 
static int parse_ext(const struct dirent *dir);

void rotate13 (uint8_t arr[]);

int main() {
  struct ftdi_context *ftdi, *ftdi_2;
  struct ftdi_device_list *devlist, *curdev, *devlist_2, *curdev_2;
  ftdi_free(ftdi);
  ftdi_free(ftdi_2);
  char manufacturer[128], description[128];
  int retval = EXIT_SUCCESS;
  char letter;
  int i = 0;
  int j = 0;
  int k = 0;
  int ret = 0;
  int res;
  int nbytes;
  int f;
  int r = 224;
  int g = 28;
  int b = 3;
  int y = 252;
  size_t write_index;
  uint8_t temp[3] = { };
  uint8_t dPack[108] = { };
  uint8_t dbytePack[108] = {0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                            0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                            0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                            0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                            0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                            0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                            0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                            0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                            0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0};

  uint8_t bytePack[108] = {y, y, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  y, y, y,  g, g, g,
                          r, b, g,  y, g, r,  r, r, r,  r, r, y};

  uint8_t testPack[108] = {r, r, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  g, g, g,  g, g, g,
                          g, g, g,  g, g, g,  g, g, g,  g, g, g};  
  uint8_t testPack_3[108] = {g, g, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  g, g, g,  g, g, g,
                          g, g, g,  g, g, g,  g, g, g,  g, g, g};
  uint8_t testPack_4[108] = {b, b, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  g, g, g,  g, g, g,
                          g, g, g,  g, g, g,  g, g, g,  g, g, g};                      
                          
  uint8_t testPack_2[108] = {y, y, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,
                          0, 0, 0,  0, 0, 0,  r, r, r,  r, r, r,
                          r, r, r,  r, r, r,  r, r, r,  r, r, r};

  uint8_t whitePack[96] = {255,255,215, 255,255,215, 255,255,215, 255,255,215, 
                           255,255,215, 255,255,215, 255,255,215, 255,255,215, 
                           255,255,215, 255,255,215, 255,255,215, 255,255,215, 
                           255,255,215, 255,255,215, 255,255,215, 255,255,215, 
                           255,255,215, 255,255,215, 255,255,215, 255,255,215, 
                           255,255,215, 255,255,215, 255,255,215, 255,255,215, 
                           255,255,215, 255,255,215, 255,255,215, 255,255,215, 
                           255,255,215, 255,255,215, 255,255,215, 255,255,215};

  uint8_t whit2Pack[96] = {255,255,255, 255,255,255, 255,255,255, 255,255,255, 
                           255,255,255, 255,255,255, 255,255,255, 255,255,255, 
                           255,255,255, 255,255,255, 255,255,255, 255,255,255, 
                           255,255,255, 255,255,255, 255,255,255, 255,255,255, 
                           255,255,255, 255,255,255, 255,255,255, 255,255,255, 
                           255,255,255, 255,255,255, 255,255,255, 255,255,255, 
                           255,255,255, 255,255,255, 255,255,255, 255,255,255, 
                           255,255,255, 255,255,255, 255,255,255, 255,255,255};

  uint8_t blkPack[96] =   {  0,0,0,       0,0,0,       0,0,0,       0,0,0,
                             0,0,0,       0,0,0,       0,0,0,       0,0,0,
                             0,0,0,       0,0,0,       0,0,0,       0,0,0,
                             0,0,0,       0,0,0,       0,0,0,       0,0,0,
                             0,0,0,       0,0,0,       0,0,0,       0,0,0,
                             0,0,0,       0,0,0,       0,0,0,       0,0,0,
                             0,0,0,       0,0,0,       0,0,0,       0,0,0,
                             0,0,0,       0,0,0,       0,0,0,       0,0,0};

  uint8_t redPack[96] =   {255,0,0,     255,0,0,     255,0,0,     255,0,0,
                           255,0,0,     255,0,0,     255,0,0,     255,0,0,
                           255,0,0,     255,0,0,     255,0,0,     255,0,0,
                           255,0,0,     255,0,0,     255,0,0,     255,0,0,
                           255,0,0,     255,0,0,     255,0,0,     255,0,0,
                           255,0,0,     255,0,0,     255,0,0,     255,0,0,
                           255,0,0,     255,0,0,     255,0,0,     255,0,0,
                           255,0,0,     255,0,0,     255,0,0,     255,0,0};

  uint8_t greenPack[96] = {0,255,0,     0,255,0,     0,255,0,     0,255,0,
                           0,255,0,     0,255,0,     0,255,0,     0,255,0,
                           0,255,0,     0,255,0,     0,255,0,     0,255,0,
                           0,255,0,     0,255,0,     0,255,0,     0,255,0,
                           0,255,0,     0,255,0,     0,255,0,     0,255,0,
                           0,255,0,     0,255,0,     0,255,0,     0,255,0,
                           0,255,0,     0,255,0,     0,255,0,     0,255,0,
                           0,255,0,     0,255,0,     0,255,0,     0,255,0};

  uint8_t bluePack[96] =  {0,0,255,     0,0,255,     0,0,255,     0,0,255,
                           0,0,255,     0,0,255,     0,0,255,     0,0,255,
                           0,0,255,     0,0,255,     0,0,255,     0,0,255,
                           0,0,255,     0,0,255,     0,0,255,     0,0,255,
                           0,0,255,     0,0,255,     0,0,255,     0,0,255,
                           0,0,255,     0,0,255,     0,0,255,     0,0,255,
                           0,0,255,     0,0,255,     0,0,255,     0,0,255,
                           0,0,255,     0,0,255,     0,0,255,     0,0,255};

  uint8_t yellowPack[96] ={255,255,0,   255,255,0,   255,255,0,   255,255,0,
                           255,255,0,   255,255,0,   255,255,0,   255,255,0,
                           255,255,0,   255,255,0,   255,255,0,   255,255,0,
                           255,255,0,   255,255,0,   255,255,0,   255,255,0,
                           255,255,0,   255,255,0,   255,255,0,   255,255,0,
                           255,255,0,   255,255,0,   255,255,0,   255,255,0,
                           255,255,0,   255,255,0,   255,255,0,   255,255,0,
                           255,255,0,   255,255,0,   255,255,0,   255,255,0};

  uint8_t orangePack[96] ={255,165,0,   255,165,0,   255,165,0,   255,165,0,
                           255,165,0,   255,165,0,   255,165,0,   255,165,0,
                           255,165,0,   255,165,0,   255,165,0,   255,165,0,
                           255,165,0,   255,165,0,   255,165,0,   255,165,0,
                           255,165,0,   255,165,0,   255,165,0,   255,165,0,
                           255,165,0,   255,165,0,   255,165,0,   255,165,0,
                           255,165,0,   255,165,0,   255,165,0,   255,165,0,
                           255,165,0,   255,165,0,   255,165,0,   255,165,0};

  uint8_t cyanPack[96] =  {0,255,255,   0,255,255,   0,255,255,   0,255,255,
                           0,255,255,   0,255,255,   0,255,255,   0,255,255,
                           0,255,255,   0,255,255,   0,255,255,   0,255,255,
                           0,255,255,   0,255,255,   0,255,255,   0,255,255,
                           0,255,255,   0,255,255,   0,255,255,   0,255,255,
                           0,255,255,   0,255,255,   0,255,255,   0,255,255,
                           0,255,255,   0,255,255,   0,255,255,   0,255,255,
                           0,255,255,   0,255,255,   0,255,255,   0,255,255};

  uint8_t magentaPack[96]={255,0,255,   255,0,255,   255,0,255,   255,0,255,
                           255,0,255,   255,0,255,   255,0,255,   255,0,255,
                           255,0,255,   255,0,255,   255,0,255,   255,0,255,
                           255,0,255,   255,0,255,   255,0,255,   255,0,255,
                           255,0,255,   255,0,255,   255,0,255,   255,0,255,
                           255,0,255,   255,0,255,   255,0,255,   255,0,255,
                           255,0,255,   255,0,255,   255,0,255,   255,0,255,
                           255,0,255,   255,0,255,   255,0,255,   255,0,255};

 // modification of green - makes channels DE (color guard) red, adds a gold  sparkle
  uint8_t tree1[96] =    {255,215,0,   0,255,0,     0,255,0,     0,255,0, //0123
                          0,255,0,     0,255,0,     0,255,0,     0,255,0, //4567
                          0,255,0,     0,255,0,     0,255,0,     0,255,0, //89AB
                          0,255,0,     255,0,0,     255,0,0,     0,255,0, //CDEF
                          0,255,0,     0,255,0,     0,255,0,     0,255,0, //0123
                          0,255,0,     0,255,0,     0,255,0,     0,255,0, //4567
                          0,255,0,     0,255,0,     0,255,0,     0,255,0, //89AB
                          0,255,0,     255,0,0,     255,0,0,     0,255,0};//CDEF

 // modification of green - makes channels DE (color guard) gold and red, adds a white sparkle
  uint8_t tree2[96] =    {255,255,255, 0,255,0,     0,255,0,     0,255,0, //0123
                          0,255,0,     0,255,0,     0,255,0,     0,255,0, //4567
                          0,255,0,     0,255,0,     0,255,0,     0,255,0, //89AB
                          0,255,0,     255,0,0,     255,215,0,   0,255,0, //CDEF
                          0,255,0,     0,255,0,     0,255,0,     0,255,0, //0123
                          0,255,0,     0,255,0,     0,255,0,     0,255,0, //4567
                          0,255,0,     0,255,0,     0,255,0,     0,255,0, //89AB
                          0,255,0,     255,0,0,     255,215,0,   0,255,0};//CDEF

 // mod of white - adds gold sparkle
  uint8_t snowman1[96] = {255,215,0,   255,255,215, 255,255,215, 255,255,215, 
                          255,255,215, 255,255,215, 255,255,215, 255,255,215, 
                          255,255,215, 255,255,215, 255,255,215, 255,255,215, 
                          255,255,215, 255,255,215, 255,255,215, 255,255,215, 
                          255,215,0,   255,255,215, 255,255,215, 255,255,215, 
                          255,255,215, 255,255,215, 255,255,215, 255,255,215, 
                          255,255,215, 255,255,215, 255,255,215, 255,255,215, 
                          255,255,215, 255,255,215, 255,255,215, 255,255,215};

 // mod of whit2 - adds a gold sparkle
 
  uint8_t snowman2[96] =  {255,215,0,   255,255,255, 255,255,255, 255,255,255, 
                           255,255,255, 255,255,255, 255,255,255, 255,255,255, 
                           255,255,255, 255,255,255, 255,255,255, 255,255,255, 
                           255,255,255, 255,255,255, 255,255,255, 255,255,255, 
                           255,215,0,   255,255,255, 255,255,255, 255,255,255, 
                           255,255,255, 255,255,255, 255,255,255, 255,255,255, 
                           255,255,255, 255,255,255, 255,255,255, 255,255,255, 
                           255,255,255, 255,255,255, 255,255,255, 255,255,255};

  uint8_t indigoPack[96] = {75,0,130,  75,0,130,  75,0,130,  75,0,130,
                            75,0,130,  75,0,130,  75,0,130,  75,0,130,
                            75,0,130,  75,0,130,  75,0,130,  75,0,130,
                            75,0,130,  75,0,130,  75,0,130,  75,0,130,
                            75,0,130,  75,0,130,  75,0,130,  75,0,130,
                            75,0,130,  75,0,130,  75,0,130,  75,0,130,
                            75,0,130,  75,0,130,  75,0,130,  75,0,130,
                            75,0,130,  75,0,130,  75,0,130,  75,0,130};

  uint8_t coralPack[96] =   {255,127,80,  255,127,80,  255,127,80,  255,127,80,
                             255,127,80,  255,127,80,  255,127,80,  255,127,80,
                             255,127,80,  255,127,80,  255,127,80,  255,127,80,
                             255,127,80,  255,127,80,  255,127,80,  255,127,80,
                             255,127,80,  255,127,80,  255,127,80,  255,127,80,
                             255,127,80,  255,127,80,  255,127,80,  255,127,80,
                             255,127,80,  255,127,80,  255,127,80,  255,127,80,
                             255,127,80,  255,127,80,  255,127,80,  255,127,80};

  uint8_t dodgerPack[96] =  {30,144,255,  30,144,255,  30,144,255,  30,144,255,
                             30,144,255,  30,144,255,  30,144,255,  30,144,255,
                             30,144,255,  30,144,255,  30,144,255,  30,144,255,
                             30,144,255,  30,144,255,  30,144,255,  30,144,255,
                             30,144,255,  30,144,255,  30,144,255,  30,144,255,
                             30,144,255,  30,144,255,  30,144,255,  30,144,255,
                             30,144,255,  30,144,255,  30,144,255,  30,144,255,
                             30,144,255,  30,144,255,  30,144,255,  30,144,255};
  
// gold is 255,215,0
  uint8_t goldPack[96] =  {255,205,0,  255,205,0,  255,205,0,  255,205,0,
                           255,205,0,  255,205,0,  255,205,0,  255,205,0, 
                           255,205,0,  255,205,0,  255,205,0,  255,205,0,
                           255,205,0,  255,205,0,  255,205,0,  255,205,0,
                           255,205,0,  255,205,0,  255,205,0,  255,205,0,
                           255,205,0,  255,205,0,  255,205,0,  255,205,0,
                           255,205,0,  255,205,0,  255,205,0,  255,205,0,
                           255,205,0,  255,205,0,  255,205,0,  255,205,0};

  uint8_t ui1Pack[96] =   {255,215,0,  255,255,215,  255,215,0,  255,255,215,
                           255,215,0,  255,255,215,  255,215,0,  255,255,215,
                           255,215,0,  255,255,215,  255,215,0,  255,255,215,
                           255,215,0,  255,255,215,  255,215,0,  255,255,215,
                           255,215,0,  255,255,215,  255,215,0,  255,255,215,
                           255,215,0,  255,255,215,  255,215,0,  255,255,215, 
                           255,215,0,  255,255,215,  255,215,0,  255,255,215,
                           255,215,0,  255,255,215,  255,215,0,  255,255,215};

  uint8_t ui2Pack[96] =   {255,255,215,  255,215,0,  255,255,215,  255,215,0,
                           255,255,215,  255,215,0,  255,255,215,  255,215,0,
                           255,255,215,  255,215,0,  255,255,215,  255,215,0,
                           255,255,215,  255,215,0,  255,255,215,  255,215,0,
                           255,255,215,  255,215,0,  255,255,215,  255,215,0, 
                           255,255,215,  255,215,0,  255,255,215,  255,215,0,
                           255,255,215,  255,215,0,  255,255,215,  255,215,0,
                           255,255,215,  255,215,0,  255,255,215,  255,215,0};

  uint8_t twnk1Pack[96] =  {85,80,0,  80,80,0,  0,155,0,  80,80,0,
                            80,80,0,  80,80,0,  155,0,0,  80,80,0,
                            60,55,0,  80,80,0,  255,255,255,  80,80,0,
                            85,80,0,  80,80,0,  80,75,0,  80,80,0, 
                        155,155,155,  80,80,0,  85,80,0,  80,80,0,
                            80,85,0,  80,80,0,  80,80,0,  80,80,0,
                          155,115,0,  80,80,0,  80,75,0,  80,80,0,
                            80,80,0,  80,80,0,  85,80,0,  80,80,0};

 uint8_t twnk2Pack[96] =   {80,80,0,  155,150,0,  80,80,0,  80,75,0,
                            80,80,0,  80,80,0,  80,80,0,  255,0,0,
                            80,80,0,  150,155,0,  80,80,0,  60,60,55,
                            80,80,0,  85,80,0,  80,80,0,  80,75,0, 
                            80,80,0,  160,160,155,  80,80,0,  85,80,0,
                            80,80,0,  80,75,0,  80,80,0,  80,80,0,
                            80,80,0,  0,0,0,  80,80,0,  80,75,0,
                            80,70,0,  80,70,0,  80,80,0,  155,115,0};

 uint8_t twnk3Pack[96] =   {80,80,0,  80,80,0,  85,80,0,  80,80,0,
                            80,75,0,  80,80,0,  80,80,155,  80,80,0,
                            85,80,0,  80,80,0,  60,55,0,  80,80,0,
                            80,80,0,  80,80,0,  155,0,0,  80,80,0,
                            80,75,0,  80,80,0,  80,80,0,  80,80,0,
                            85,80,0,  80,80,0,  0,155,0,  80,80,0,
                            80,80,0,  0,0,0,  85,80,0,  80,80,0,
                            80,75,0,  80,80,0,  0,0,155,  80,80,0};

 uint8_t twnk4Pack[96] = {155,0,0, 80,80,75, 80,85,0, 255,215,0, 
                          80,80,0, 80,75,0,  255,255,215, 80,80,0, 
                          80,75,0, 85,80,0,  80,80,0, 80,75,0, 
                          85,80,0, 80,80,0,  80,75,0, 85,80,0, 
                          0,0,0,   80,75,0,  85,80,0, 80,80,0, 
                          80,75,0, 85,80,0,  80,80,0, 80,75,0, 
                          0,0,0,   80,80,0,  255,115,0, 85,80,0, 
                          80,80,0, 80,75,0, 85,80,0, 80,80,0};

 uint8_t twnk5Pack[96] = {80,75,0, 255,0,0, 80,80,0, 80,75,0, 
                          85,80,0, 0,0,255, 80,75,0, 255,215,0, 
                          80,80,0, 80,75,0, 85,80,0, 80,80,0, 
                          80,75,0, 255,0,0, 80,80,75, 0,255,0, 
                          85,80,0, 80,80,0, 80,75,0, 255,215,0, 
                          80,80,0, 80,75,0, 85,80,0, 80,80,0, 
                          80,75,0, 255,215,0, 80,80,0, 80,75,0, 
                          85,80,0, 0,0,255, 80,75,0, 85,80,0};

 uint8_t twnk6Pack[96] = {80,80,0, 0,255,0, 255,215,0, 80,80,0, 
                          80,75,0, 85,80,0, 80,80,0, 80,75,0, 
                          255,0,0, 80,80,0, 0,255,0, 85,80,0, 
                          80,80,0, 80,75,0, 85,80,0, 80,80,0, 
                          0,255,0, 85,80,0, 0,0,255, 80,75,0, 
                          85,80,0, 80,80,0, 0,255,0, 85,80,0, 
                          80,80,0, 80,75,0, 255,0,0, 80,80,0, 
                          0,255,0, 85,80,0, 0,0,255, 80,75,0};


 uint8_t twnk7Pack[96] = {85,80,0, 80,80,0, 80,75,0, 255,215,0, 
                          80,80,0, 0,255,0, 85,80,0, 80,80,0, 
                          80,75,0, 255,215,0, 80,80,0, 80,75,0, 
                          255,215,0, 0,0,255, 80,75,0, 255,215,0, 
                          80,80,05, 80,75,0, 85,80,0, 80,80,0, 
                          80,75,0, 255,215,0, 80,80,0, 0,255,0, 
                          85,80,0, 80,80,0, 80,75,0, 255,215,0, 
                          80,80,0, 80,75,0, 85,80,0, 0,0,255};
  
 uint8_t twnk8Pack[96] = {255,255,0, 255,215,0, 80,80,0, 80,75,0, 
                          255,215,0, 80,80,0, 80,75,0, 255,215,0, 
                          80,80,0, 80,75,0, 255,215,0, 80,80,0, 
                          80,75,0, 75,75,0, 80,80,0, 80,75,0, 
                          255,215,0, 80,80,0, 80,75,0, 255,0,0, 
                          80,80,0, 0,255,0, 255,215,0, 80,80,0, 
                          80,75,0, 85,80,0, 80,80,0, 80,75,0, 
                          255,215,0, 80,80,0, 80,75,0, 85,80,0};

 uint8_t twnk9Pack[96] = {85,85,0, 80,75,0, 255,215,0, 80,80,0, 
	                  80,75,0, 75,75,0, 80,80,0, 80,75,0, 
			  255,215,0, 80,80,0, 80,75,0, 75,75,0, 
			  80,80,0, 80,75,0, 255,215,0, 80,80,0, 
			  80,75,0, 255,215,0, 80,80,255, 80,75,0, 
			  85,80,0, 80,80,0, 80,75,0, 255,215,0, 
			  80,80,0, 80,75,0, 85,80,0, 0,0,255, 
			  80,75,0, 255,215,0, 80,80,0, 0,255,0};

uint8_t twnk10Pack[96] = {85,75,0, 255,255,255, 80,75,0, 255,215,0, 
	                  80,80,0, 80,75,0, 255,215,0, 80,80,0, 
			  80,75,0, 255,215,0, 80,80,0, 80,75,0, 
			  255,215,0, 80,80,0, 80,75,0, 255,215,0, 
			  80,80,0, 80,75,0, 255,215,0, 80,80,0, 
			  80,75,0, 255,0,0, 0,0,255, 0,255,0, 
			  255,215,0, 80,80,0, 80,75,0, 85,80,0, 
			  80,80,0, 80,75,0, 255,215,0, 80,80,0};

uint8_t twnk11Pack[96] = {80,75,0, 85,85,0, 255,255,255, 80,75,0, 
	                  255,215,0, 80,80,0, 0,255,0, 255,215,0, 
			  80,80,0, 80,75,0, 255,215,0, 0,0,255, 
			  80,75,0, 255,215,0, 80,80,0, 80,75,0, 
			  255,215,0, 80,80,0, 80,75,0, 255,215,0, 
			  80,80,0, 80,85,0, 255,0,0, 80,80,0, 
			  80,75,0, 255,215,0, 80,80,0, 0,255,0, 
			  85,80,0, 80,80,0, 80,75,0, 255,215,0};

uint8_t twnk12Pack[96] = {85,80,0, 80,80,0, 150,135,0, 80,80,0, 
	                  80,80,0, 80,80,0, 155,140,0, 80,80,0, 
			  80,85,0, 80,80,0, 70,70,0, 80,80,0, 
			  85,80,0, 80,80,0, 70,65,0, 80,80,0, 
			  170,170,155, 80,80,0, 155,150,0, 80,80,0, 
			  70,65,0, 80,80,0, 60,60,55, 80,80,0, 
			  155,115,0, 80,80,0, 70,65,0, 80,80,0, 
			  70,70,55, 80,80,0, 55,50,0, 80,80,0};

uint8_t twnk13Pack[96] = {0,0,0, 155,140,0, 0,0,0, 60,55,0, 
                 	  0,0,0, 70,70,55, 0,0,0, 55,50,0, 
			  0,0,0, 170,155,0, 0,0,0, 60,60,55, 
			  0,0,0, 55,50,0, 0,0,0, 60,55,0, 
			  0,0,0, 170,170,155, 0,0,0, 55,50,0, 
			  0,0,0, 60,55,0, 0,0,0, 60,60,55, 
			  0,0,0, 155,140,0, 0,0,0, 60,55,0, 
			  0,0,0, 60,60,55, 0,0,0, 155,115,0};


 uint8_t rain1Pack[96] = {255,255,255, 255,0,0, 0,255,0, 0,0,255, 
	                  255,255,0, 0,255,255, 255,0,255, 0,0,0, 
			  255,127,80, 30,144,255, 255,215,0, 220,20,60, 
			  141,239,79, 0,0,0, 0,206,209, 186,85,211, 
			  255,255,255, 255,0,0, 0,255,0, 0,0,255, 
			  255,255,0, 0,255,255, 255,0,255, 0,0,0, 
			  255,127,80, 30,144,255, 255,215,0, 220,20,60, 
			  141,239,79, 0,0,0, 0,206,209, 186,85,211};

 uint8_t rain2Pack[96] = {186,85,211, 255,255,255, 255,0,0, 0,255,0, 
	                  0,0,255, 255,255,0, 0,255,255, 255,0,255, 
			  75,0,130, 255,127,80, 0,0,0, 255,215,0, 
			  0,0,0, 141,239,79, 0,0,0, 0,206,209, 
			  186,85,211, 255,255,255, 255,0,0, 0,255,0, 
			  0,0,255, 255,255,0, 0,255,255, 255,0,255, 
			  0,0,0, 255,127,80, 30,144,255, 255,215,0, 
			  0,0,0, 141,239,79, 131,194,209, 0,206,209};

 uint8_t rain3Pack[96] = {0,206,209, 186,85,211, 255,255,255, 255,0,0, 
	                  0,255,0, 0,0,255, 255,255,0, 0,255,255, 
			  255,0,255, 0,0,0, 255,127,80, 30,144,255, 
			  255,215,0, 220,20,60, 141,239,79, 0,0,0, 
			  0,206,209, 186,85,211, 255,255,255, 255,0,0, 
			  0,255,0, 0,0,255, 255,255,0, 0,255,255, 
			  255,0,255, 0,0,0, 255,127,80, 30,144,255, 
			  255,215,0, 220,20,60, 141,239,79, 0,0,0};

 uint8_t rain4Pack[96] = {0,0,0, 0,206,209, 186,85,211, 255,255,255, 
	                  255,0,0, 0,255,0, 0,0,255, 255,255,0, 
			  0,255,255, 255,0,255, 0,0,0, 255,127,80, 
			  30,144,255, 255,215,0, 220,20,60, 141,239,79, 
			  31,194,109, 0,206,209, 186,85,211, 255,255,255, 
			  255,0,0, 0,255,0, 0,0,255, 255,255,0, 
			  0,255,255, 255,0,255, 0,0,0, 255,127,80, 
			  30,144,255, 255,215,0, 220,20,60, 141,239,79};

 uint8_t rain5Pack[96] = {141,239,79, 31,194,109, 0,206,209, 186,85,211, 
	                  255,255,255, 255,0,0, 0,255,0, 0,0,255, 
			  255,255,0, 0,255,255, 255,0,255, 0,0,0, 
			  255,127,80, 30,0,55, 255,215,0, 220,20,60, 
			  141,239,79, 31,194,109, 0,206,209, 186,85,211, 
			  255,255,255, 255,0,0, 0,255,0, 0,0,255, 
			  255,255,0, 0,255,255, 255,0,255, 75,0,0, 
			  255,127,80, 0,0,0, 255,215,0, 220,20,60};

 uint8_t rain6Pack[96] = {220,20,60, 141,239,79, 0,0,0, 0,206,209, 
	                  186,85,211, 255,255,255, 255,0,0, 0,255,0, 
			  0,0,255, 255,255,0, 0,255,255, 255,0,255, 
			  0,0,0, 255,127,80, 30,144,255, 255,215,0, 
			  220,20,60, 141,239,79, 31,0,0, 0,206,209, 
			  186,85,211, 255,255,255, 255,0,0, 0,255,0, 
			  0,0,255, 255,255,0, 0,255,255, 255,0,255, 
			  0,0,0, 255,127,80, 30,144,255, 255,215,0};

 uint8_t rain7Pack[96] = {255,215,0, 220,20,60, 141,239,79, 31,194,109, 
	                  0,206,209, 186,85,211, 255,255,255, 255,0,0, 
			  0,255,0, 0,0,255, 255,255,0, 0,255,255, 
			  255,0,255, 75,0,130, 255,127,80, 30,144,255, 
			  255,215,0, 220,20,60, 141,239,79, 31,194,109, 
			  0,206,209, 186,85,211, 255,255,255, 255,0,0, 
			  0,255,0, 0,0,255, 255,255,0, 0,255,255, 
			  255,0,255, 75,0,130, 255,127,80, 30,144,255};

 uint8_t rain8Pack[96] = {30,144,255, 255,215,0, 220,20,60, 141,239,79, 
	                  31,194,109, 0,206,209, 186,85,211, 255,255,255, 
			  255,0,0, 0,255,0, 0,0,255, 255,255,0, 
			  0,255,255, 255,0,255, 75,0,130, 255,127,80, 
			  30,144,255, 255,215,0, 220,20,60, 141,239,79, 
			  31,194,109, 0,206,209, 186,85,211, 255,255,255, 
			  255,0,0, 0,255,0, 0,0,255, 255,255,0, 
			  0,255,255, 255,0,255, 75,0,130, 255,127,80};

 uint8_t rain9Pack[96] = {255,127,80, 30,144,255, 255,215,0, 220,20,60, 
	                  141,239,79, 31,194,109, 0,206,209, 186,85,211, 
			  255,255,255, 255,0,0, 0,255,0, 0,0,255, 
			  255,255,0, 0,255,255, 255,0,255, 75,0,130, 
			  255,127,80, 30,144,255, 255,215,0, 220,20,60, 
			  141,239,79, 31,194,109, 0,206,209, 186,85,211, 
			  255,255,255, 255,0,0, 0,255,0, 0,0,255, 
			  255,255,0, 0,255,255, 255,0,255, 75,0,130};

uint8_t rain10Pack[96] = {75,0,130, 255,127,80, 30,144,255, 255,215,0, 
	                  220,20,60, 141,239,79, 31,194,109, 0,206,209, 
			  186,85,211, 255,255,255, 255,0,0, 0,255,0, 
			  0,0,255, 255,255,0, 0,255,255, 255,0,255, 
			  75,0,130, 255,127,80, 30,144,255, 255,215,0, 
			  220,20,60, 141,239,79, 31,194,109, 0,206,209, 
			  186,85,211, 255,255,255, 255,0,0, 0,255,0, 
			  0,0,255, 255,255,0, 0,255,255, 255,0,255};

uint8_t rain11Pack[96] = {255,0,255, 75,0,130, 255,127,80, 30,144,255, 
	                  255,215,0, 220,20,60, 141,239,79, 31,194,109, 
			  0,206,209, 186,85,211, 255,255,255, 255,0,0, 
			  0,255,0, 0,0,255, 255,255,0, 0,255,255, 
			  255,0,255, 75,0,130, 255,127,80, 30,144,255, 
			  255,215,0, 220,20,60, 141,239,79, 31,194,109, 
			  0,206,209, 186,85,211, 255,255,255, 255,0,0, 
			  0,255,0, 0,0,255, 255,255,0, 0,255,255};

uint8_t rain12Pack[96] = {0,255,255, 255,0,255, 75,0,130, 255,127,80, 
	                  30,144,255, 255,215,0, 220,20,60, 141,239,79, 
			  31,194,109, 0,206,209, 186,85,211, 255,255,255, 
			  255,0,0, 0,255,0, 0,0,255, 255,255,0, 
			  0,255,255, 255,0,255, 75,0,130, 255,127,80, 
			  30,144,255, 255,215,0, 220,20,60, 141,239,79, 
			  31,194,109, 0,206,209, 186,85,211, 255,255,255, 
			  255,0,0, 0,255,0, 0,0,255, 255,255,0};

uint8_t rain13Pack[96] = {255,255,0, 0,255,255, 255,0,255, 75,0,130, 
	                  255,127,80, 30,144,255, 255,215,0, 220,20,60, 
			  141,239,79, 31,194,109, 0,206,209, 186,85,211, 
			  255,255,255, 255,0,0, 0,255,0, 0,0,255, 
			  255,255,0, 0,255,255, 255,0,255, 75,0,130, 
			  255,127,80, 30,144,255, 255,215,0, 220,20,60, 
			  141,239,79, 31,194,109, 0,206,209, 186,85,211, 
			  255,255,255, 255,0,0, 0,255,0, 0,0,255};

uint8_t rain14Pack[96] = {0,0,255, 255,255,0, 0,255,255, 255,0,255, 
	                  75,0,130, 255,127,80, 30,144,255, 255,215,0, 
			  220,20,60, 141,239,79, 31,194,109, 0,206,209, 
			  186,85,211, 255,255,255, 255,0,0, 0,255,0, 
			  0,0,255, 255,255,0, 0,255,255, 255,0,255, 
			  75,0,130, 255,127,80, 30,144,255, 255,215,0, 
			  220,20,60, 141,239,79, 31,194,109, 0,206,209, 
			  186,85,211, 255,255,255, 255,0,0, 0,255,0};

uint8_t rain15Pack[96] = {0,255,0, 0,0,255, 255,255,0, 0,255,255, 
	                  255,0,255, 75,0,130, 255,127,80, 30,144,255, 
			  255,215,0, 220,20,60, 141,239,79, 31,194,109, 
			  0,206,209, 186,85,211, 255,255,255, 255,0,0, 
			  0,255,0, 0,0,255, 255,255,0, 0,255,255, 
			  255,0,255, 75,0,130, 255,127,80, 30,144,255, 
			  255,215,0, 220,20,60, 141,239,79, 31,194,109, 
			  0,206,209, 186,85,211, 255,255,255, 255,0,0};

uint8_t rain16Pack[96] = {255,0,0, 0,255,0, 0,0,255, 255,255,0, 
	                  0,255,255, 255,0,255, 75,0,130, 255,127,80, 
			  30,144,255, 255,215,0, 220,20,60, 141,239,79, 
			  31,194,109, 0,206,209, 186,85,211, 255,255,255, 
			  255,0,0, 0,255,0, 0,0,255, 255,255,0, 
			  0,255,255, 255,0,255, 75,0,130, 255,127,80, 
			  30,144,255, 255,215,0, 220,20,60, 141,239,79, 
			  31,194,109, 0,206,209, 186,85,211, 255,255,255};

 uint8_t glowPack[96] = {85,80,0,  80,80,0,  80,85,0,  85,80,0,
                         80,80,0,  80,75,0,  95,90,0,  80,80,0,
                         80,80,0,  85,80,0,  80,80,0,  70,70,0,
                         75,70,0,  70,70,0,  70,70,0,  75,70,0, 
                         70,70,0,  70,70,0,  75,70,0,  70,70,0,
                         70,70,0,  75,70,0,  70,70,0,  70,75,0,
                         75,70,0,  70,70,0,  75,75,0,  75,70,0,
                         70,70,0,  70,70,0,  75,70,0,  70,70,0};

  uint8_t rnPack[96] = {255,0,0,  255,0,0,  255,0,0,  0,0,0,
                        0,255,0,  0,255,0,  0,255,0,  0,0,0,
                        0,0,255,  0,0,255,  0,0,255,  0,0,0,
                        255,255,0,  255,255,0,  255,255,0,  0,0,0,
                        0,255,255,  0,255,255,  0,255,255,  0,0,0,
                        255,0,255,  255,0,255,  255,0,255,  0,0,0,
                        255,255,215,  255,255,215,  255,255,215,  0,0,0,
                        255,215,0,  255,215,0,  255,215,0,  0,0,0};

  uint8_t igPack[96] = {255,255,215,  255,255,215, 255,255,215, 255,255,215,  
                        255,  0,  0,  255,  0,  0, 255,  0,  0, 255,  0,  0,  
                          0,255,  0,    0,255,  0,   0,255,  0,   0,255,  0,  
                          0,  0,255,    0,  0,255,   0,  0,255,   0,  0,255,
                        255,255,215,  255,255,215, 255,255,215, 255,255,215,  
                        255,  0,  0,  255,  0,  0, 255,  0,  0, 255,  0,  0,  
                          0,255,  0,    0,255,  0,   0,255,  0,   0,255,  0,  
                          0,  0,255,    0,  0,255,   0,  0,255,   0,  0,255,
                       };

 uint8_t itPack[96] = {255,255,215,  255,255,215,  0,0,0,  0,0,0,
                       0,0,0,  0,0,0,  0,0,0,  0,0,0,
                       0,0,0,  0,0,0,  0,0,0,  0,0,0,
                       255,215,0,  255,215,0,  0,0,0,  0,0,0,
                       0,0,0,  0,0,0,  0,0,0,  0,0,0,
                       255,215,0,  255,215,0,  0,0,0,  0,0,0,
                       0,0,0,  0,0,0,  0,0,0,  0,0,0,
                       255,215,0,  255,215,0,  0,0,0,  0,0,0};

 uint8_t X1Pack[96] =     {255,0,0,     0,255,0,     255,0,0,     0,255,0, 
                           255,0,0,     0,255,0,     255,215,0,   255,0,0, 
                           0,255,0,     255,0,0,     0,255,0,     255,0,0, 
                           255,215,0,   0,255,0,     255,0,0,     0,255,0, 
                           255,0,0,     0,255,0,     255,0,0,     0,255,0, 
                           255,215,0,   255,215,0,   255,0,0,     0,255,0, 
                           255,0,0,     0,255,0,     255,0,0,     0,255,0, 
                           255,215,0,   255,215,0,   255,0,0,     0,255,0};

 uint8_t X2Pack[96] =  {255,215,0,   255,0,0,     0,255,0,     255,0,0,  // 0123
                        0,255,0,     255,0,0,     0,255,0,     255,0,0,  // 4567
                        0,255,0,     255,215,0,   255,0,0,     0,255,0,  // 89AB
                        255,0,0,    0,255,0,    255,0,0,     255,215,0,  // CDEF
                        0,255,0,     255,0,0,     0,255,0,     255,0,0,  // 0123
                        0,255,0,     255,0,0,     0,255,0,     255,215,0,// 4567
                        255,215,0,   255,0,0,     0,255,0,     255,0,0,  // 89AB
                        0,255,0,     255,0,0,     0,255,0,     255,215,0};//DCEF

 uint8_t X3Pack[96] =     {255,0,0,     0,255,0,     255,215,0,   255,215,0, 
                           255,0,0,     0,255,0,     255,0,0,     0,255,0, 
                           255,0,0,     0,255,0,     255,0,0,     0,255,0, 
                           255,215,0,   255,0,0,     0,255,0,     255,0,0, 
                           0,255,0,     255,0,0,     255,215,0,   0,255,0, 
                           255,0,0,     0,255,0,     255,0,0,     0,255,0, 
                           255,0,0,     0,255,0,     255,215,0,   255,215,0, 
                           255,0,0,     0,255,0,     255,0,0,     0,255,0};

 uint8_t X4Pack[96] =     {0,255,0,     255,0,0,     0,255,0,     255,0,0, 
                           0,255,0,     255,215,0,   255,215,0,   255,0,0, 
                           0,255,0,     255,0,0,     0,255,0,     255,0,0, 
                           0,255,0,     255,0,0,     0,255,0,     255,215,0, 
                           255,0,0,     0,255,0,     255,0,0,     0,255,0, 
                           255,0,0,     255,215,0,   0,255,0,     255,0,0, 
                           0,255,0,     255,0,0,     0,255,0,     255,0,0, 
                           0,255,0,     255,215,0,   255,215,0,   255,0,0};

  uint8_t rgPack[96] =    {255,0,0,     255,0,0,     255,0,0,     255,0,0,
                           0,255,0,     0,255,0,     0,255,0,     0,255,0,
                           255,0,0,     255,0,0,     255,0,0,     255,0,0,
                           0,255,0,     0,255,0,     0,255,0,     0,255,0,
                           255,0,0,     255,0,0,     255,0,0,     255,0,0,
                           0,255,0,     0,255,0,     0,255,0,     0,255,0,
                           255,0,0,     255,0,0,     255,0,0,     255,0,0,
                           0,255,0,     0,255,0,     0,255,0,     0,255,0};

  uint8_t grPack[96] =    {0,255,0,     0,255,0,     0,255,0,     0,255,0,
                           255,0,0,     255,0,0,     255,0,0,     255,0,0,
                           0,255,0,     0,255,0,     0,255,0,     0,255,0,
                           255,0,0,     255,0,0,     255,0,0,     255,0,0,
                           0,255,0,     0,255,0,     0,255,0,     0,255,0,
                           255,0,0,     255,0,0,     255,0,0,     255,0,0,
                           0,255,0,     0,255,0,     0,255,0,     0,255,0,
                           255,0,0,     255,0,0,     255,0,0,     255,0,0};

  size_t n = sizeof(whitePack);
  size_t l = sizeof(dest);
  size_t m = getEncodedBufferSize(l);
  struct ftdi_context * ftdi_devices[2];
  struct ftdi_device_list * ftdi_device_list[2];
  // initialize two new ftdi devices
  if ((ftdi = ftdi_new()) == 0) {
      fprintf(stderr, "ftdi_new failed\n");
      return EXIT_FAILURE;
    } else {
    fprintf(stderr, "ftdi_new success\n");
  }
  // initialize second ftdi device
  if ((ftdi_2 = ftdi_new()) == 0) {
      fprintf(stderr, "ftdi_new failed\n");
      return EXIT_FAILURE;
    } else {
    fprintf(stderr, "ftdi_new success\n");
  }


  //Loop through the array and detect each ftdi device
  for(int i = 0; i < 2; i++)  {
    if (ftdi_usb_find_all(ftdi_devices[i], &ftdi_device_list[i], 0x0403, 0x6015) < 1) {
      if(ftdi_usb_find_all(ftdi_devices[i], &ftdi_device_list[i], 0x0403, 0x6001) < 1)  {
        printf("no ftdi devices found for ftdi device slot %d\n", i);
      }  
    }
    printf("\n%d\n", i);
  }

  // detect connected ftdi device(s)
  if (((ftdi_usb_find_all(ftdi, &devlist, 0x0403, 0x6015)) < 1) && ((ftdi_usb_find_all(ftdi_2, &devlist_2, 0x0403, 0x6001)) < 1)) {
    fprintf(stderr, "no ftdi devices found\n");
    fflush(stderr);
    ftdi_list_free(&devlist);
    ftdi_list_free(&devlist_2);
    ftdi_free(ftdi);
    ftdi_free(ftdi_2);
    return 1;
  } else {

  }

  //Track the currently assigned device number
  int device_number = 0;

  ftdi_usb_find_all(ftdi, &devlist, 0x0403, 0x6015);
  // loop through detected devices and attempt to get their information
  // This should loop though all FTDI devices that have the VID:PID of 0x403:0x6015
  i = 0;
  for (curdev = devlist; curdev != NULL; i++) {
      printf("Checking device: 1\n");
      if ((ret = ftdi_usb_get_strings(ftdi, curdev->dev, manufacturer, 128, description, 128, NULL, 0)) < 0) {
        fprintf(stderr, "ftdi_usb_get_strings failed: %d (%s)\n", ret, ftdi_get_error_string(ftdi));
        retval = EXIT_FAILURE;
        ftdi_list_free(&devlist);
        ftdi_free(ftdi);
      }
      else  {
        if(device_number == 0)  {
          ftdi_devices[device_number] = ftdi;
          ftdi_device_list[device_number] = curdev;
          device_number++;
        }
        else {
          ftdi_usb_find_all(ftdi_2, &devlist_2, 0x0403, 0x6001);
          ftdi_devices[device_number] = ftdi_2;
          ftdi_device_list[device_number] = devlist_2->next;
          device_number++;
        }
      }
    printf("Device One: Manufacturer: %s, Description: %s\n\n", manufacturer, description);
    curdev = curdev->next;
    }

    
  ftdi_usb_find_all(ftdi, &devlist, 0x0403, 0x6001);
  i = 0;
  for (curdev = devlist; curdev != NULL; i++) {
      printf("Checking device: 2\n");
      if ((ret = ftdi_usb_get_strings(ftdi, curdev->dev, manufacturer, 128, description, 128, NULL, 0)) < 0) {
        fprintf(stderr, "ftdi_usb_get_strings failed: %d (%s)\n", ret, ftdi_get_error_string(ftdi));
        retval = EXIT_FAILURE;
        ftdi_list_free(&devlist);
        ftdi_free(ftdi);
      }
      else  {
        if(device_number == 0)  {
          ftdi_devices[device_number] = ftdi;
          ftdi_device_list[device_number] = curdev;
          device_number++;
        }
        else {
          ftdi_usb_find_all(ftdi_2, &devlist_2, 0x0403, 0x6001);
          ftdi_devices[device_number] = ftdi_2;
          ftdi_device_list[device_number] = devlist_2->next;
          device_number++;
        }
      }
    printf("Device Two: Manufacturer: %s, Description: %s\n\n", manufacturer, description);
    curdev = curdev->next;
  }

  //convert back to seperate ftdi contexts (might be unnecessary)
  ftdi = ftdi_devices[0];
  devlist = ftdi_device_list[0];
  ftdi_2 = ftdi_devices[1];
  devlist_2 = ftdi_device_list[1];

  bool two_devices = true;
  if(device_number < 2) {
    two_devices = false;
  }

  // open ftdi context
  if ((ret = ftdi_usb_open_dev(ftdi, devlist->dev)) < 0)
    {
      fprintf(stderr, "unable to open ftdi: %d (%s)\n", ret, ftdi_get_error_string(ftdi));
      ftdi_free(ftdi);
      return ret;            
    }
  else {
    fprintf(stderr, "ftdi_open successful\n");
  }

  // set the base bitrate/baudrate of the device(s)
  ret = ftdi_set_baudrate(ftdi, 57600);
  if (ret < 0) {
    fprintf(stderr, "unable to set baud rate: %d (%s).\n", ret, ftdi_get_error_string(ftdi));
  } else {
    printf("baudrate set.\n");
  }

if(two_devices == true) {
    if ((ret = ftdi_usb_open_dev(ftdi_2, devlist_2->dev)) < 0)
      {
        fprintf(stderr, "unable to open ftdi: %d (%s)\n", ret, ftdi_get_error_string(ftdi_2));
        ftdi_free(ftdi_2);
        return ret;            
      }
    else {
      fprintf(stderr, "ftdi_open two successful\n");
    }

    ret = ftdi_set_baudrate(ftdi_2, 57600);
    if (ret < 0) {
    fprintf(stderr, "unable to set baud rate: %d (%s).\n", ret, ftdi_get_error_string(ftdi_2));
    } else {
      printf("baudrate set.\n");
    }

    f = ftdi_set_line_property(ftdi_2, 8, STOP_BIT_1, NONE);
    if(f < 0) {
      fprintf(stderr, "unable to set line parameters: %d (%s).\n", ret, ftdi_get_error_string(ftdi));
    } else {
      printf("line parameters set.\n");
    }
  }


  // set parameters in the devices
  f = ftdi_set_line_property(ftdi, 8, STOP_BIT_1, NONE);
  if(f < 0) {
    fprintf(stderr, "unable to set line parameters: %d (%s).\n", ret, ftdi_get_error_string(ftdi));
  } else {
    printf("line parameters set.\n");
  }
  

  ftdi_list_free(&devlist);
  if(two_devices == true) {
    ftdi_list_free(&devlist_2);
  }
  printf("broadcasting.\n");

  FILE * test_file = fopen("test_ht13", "r");

  //open curses session for display purposes
  initscr();
  raw();
  keypad(stdscr, TRUE);
  nodelay(stdscr, TRUE);
  noecho();
  attron(A_BOLD);
  

  //LEAVING OFF HERE it can now read an entire file but can't differentiate between patterns and time is not yet being saved.
  FILE *fp;
  long lSize;
  char *glasses_information;
//Read all files in folder searching for ht13 files
struct dirent **namelist;
struct dirent **filtered_list;
int z;

z = scandir(".", &namelist, parse_ext, alphasort);
if (z < 0) {
  perror("scandir");
  return 1;
}
else  {

}
//dimensions of the 3-d array
// For the information being collected there are z blocks of 2-d arrays, 30 rows max of patterns and 108 addresses per pattern.
//Allocate memory blocks based on number of files here **********************************
uint8_t ***test_converted_ht13 = (uint8_t***)malloc(z * sizeof(uint8_t**));
if (test_converted_ht13 == NULL)
{
  fprintf(stderr, "Not enough memory available");
  exit(0);
} 

for (int i = 0; i < z; i++)
{
  //30 is used here as a placeholder for maximum number of patterns allowed.
  test_converted_ht13[i] = (uint8_t**)malloc(30 * sizeof(uint8_t*));
  if (test_converted_ht13[i] == NULL)
  {
    fprintf(stderr, "Not enough memory available");
    exit(0);
  }
  //110 slots of memory are available to enable reading of the time.
  for (int q = 0; q < 110; q++)
  {
    test_converted_ht13[i][q] = (uint8_t*)malloc(108 * sizeof(uint8_t));
    if (test_converted_ht13[i][q] == NULL)  
    {
      fprintf(stderr, "Out of memory");
      exit(0);
    }
  }
}
//Allocate memory in the same way to hold the time values minus the step involving an extra 108 slots
int *time_converted_ht13[z];

if (time_converted_ht13 == NULL)
{
  fprintf(stderr, "Not enough memory available");
  exit(0);
} 

for (int i = 0; i < z; i++)
{
  //30 is used here as a placeholder for maximum number of patterns allowed.
  time_converted_ht13[i] = (int*)malloc(30 * sizeof(int));
  if (time_converted_ht13[i] == NULL)
  {
    fprintf(stderr, "Not enough memory available");
    exit(0);
  }
}

int pattern_total = 0;
char keybind[30];
for (int i = 0; i < 30; i++)  {
  keybind[i] = 'N';
}
//for all ht13 files make a pattern
while (z--) {
    //printw("%s\n", namelist[z]->d_name);


  fp = fopen ( namelist[z]->d_name , "r" );
  if( !fp ) perror("ht13 file failed to open"),exit(1);

  fseek( fp , 0L , SEEK_END);
  lSize = ftell( fp );
  rewind( fp );

  /* allocate memory for entire content */
  glasses_information = calloc( 1, lSize+1 );
  if( !glasses_information ) fclose(fp),fputs("memory alloc fails",stderr),exit(1);

  /* copy the file into the buffer */
  if( 1!=fread( glasses_information , lSize, 1 , fp) )
    fclose(fp),free(glasses_information),fputs("entire read fails",stderr),exit(1);

  int keybind_location = strlen(glasses_information);
  keybind[z] = glasses_information[keybind_location-1];
  printw("\n%c\n", keybind[z]);

  //This should be looped based on which file the program is on.
  create_patterns(glasses_information, test_converted_ht13, time_converted_ht13, z);
}
for (int i = 0; i < 108; i++) {
    //printw("%i ", test_converted_ht13[0][0][i]);
}
    //printw("\n");
    //printw("TIME: %d pattern 1, %d pattern 2", time_converted_ht13[0][0], time_converted_ht13[0][1]);
    //printw("\n");
  /*for (int i = 0; i < 108; i++) {
    printw("%i ", test_converted_ht13[1][0][i]);
  }
  printw("\n");
    printw("TIME: %d", time_converted_ht13[1][0]);
    printw("\n");
    */
//take the information in the array and make a uint8_t insert_name[108] array out of it
//test_converted_ht13[address] = color_value;

//incorporate the timers for how long each part should be displayed
//for (int i = 0; glasses_information[i]; i++)
//printw("%c", glasses_information[i]);

free(glasses_information);
  printw("Hello, welcome to Ben's Halftime Toolkit!\n");
  printw("= is the new byte test\n");
  printw("5 is the converted file test");
  printw("\n");
  printw(" comma key <,> to stop loop\n");
  printw(" dot key <.> to quit");

  int q = 0;
  int key_pressed = 0;
  bool is_valid = false;
  // loop until a '.' character is detected
  do {
    letter = getch();
	  move(15,0);
	  printw("%c",(letter==-1 ? ' ' : letter));
	  move(15,0);
	  refresh();
    //adjusting statements to try automatically generated patterns from reading from file.
    q = 0;
    key_pressed = 0;
    is_valid = false;
    for(int i = 0; keybind[i]; i++)
    {
      if(letter == keybind[i])
      {
        is_valid = true;
        key_pressed = i;
        printw("%d", key_pressed);
      }
    }
    if(is_valid == true)
    {
      q = 0;
      //begin by writing the first pattern to the ftdi devices
      int loop = 0;
      clock_t start, current;

      while ((time_converted_ht13[key_pressed][q] != -1))
      {
        //printw("%d ", q);
      //The code just breaks without this usleep. I do not understand.
      usleep(20000);
      start = clock();
      nbytes = ftdi_write_data(ftdi, test_converted_ht13[key_pressed][q], m);
      //sleep for amount of time for specified pattern for the amount of time the pattern is to stay on
      //make the sleep interruptable no matter how long it is by checking for getch()
        long elapsed = 0;
        current = clock();
        //printw("%d %d", current, test_converted_ht13[letter-48][q]);
        while ((elapsed) < time_converted_ht13[key_pressed][q] && getch() != ',')
        {
          current = clock();
          elapsed = ((double)current - start) / CLOCKS_PER_SEC * 1000;
        }
      q++;
      nbytes = ftdi_write_data(ftdi, dbytePack, m);
      usleep(20000);
      }
    }
    else  {
    switch(letter) {

case '6': // function to play pattern
      do {
        nbytes = ftdi_write_data(ftdi, test_converted_ht13[1][0], m);
        if(two_devices == true) {
          nbytes = ftdi_write_data(ftdi_2, testPack_2, m);
        }
        //printf("%ld\n", m);
        usleep(DOT);
      } while (getch() != ',');  
      nbytes = ftdi_write_data(ftdi, dbytePack, m);
      if(two_devices == true) {
        nbytes = ftdi_write_data(ftdi_2, dbytePack, m);
      }
      break;
    case '5': // function to play pattern
      do {
        nbytes = ftdi_write_data(ftdi, test_converted_ht13[0][0], m);
        if(two_devices == true) {
          nbytes = ftdi_write_data(ftdi_2, testPack_2, m);
        }
        //printf("%ld\n", m);
        usleep(DOT);
      } while (getch() != ',');  
      nbytes = ftdi_write_data(ftdi, dbytePack, m);
      if(two_devices == true) {
        nbytes = ftdi_write_data(ftdi_2, dbytePack, m);
      }
      break;
    case 'b':  // blue flash
      nbytes = ftdi_write_data(ftdi, bluePack, m);
      usleep(DAB);
      break;

    case ' ': // christmas pulse
      for (i = 0; i < 2; i++) {
        nbytes = ftdi_write_data(ftdi, X1Pack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, X2Pack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, X3Pack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, X4Pack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
      }
      break;

    case 'c':  // christmas sparkle
      do {
        nbytes = ftdi_write_data(ftdi, X1Pack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, X2Pack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, X3Pack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, X4Pack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
      } while (getch() != ',');  
      break;


    case 'd':  // dark
      nbytes = ftdi_write_data(ftdi, dPack, m);
      usleep(DAB);
      break;

    case 'e':  // green flash
      nbytes = ftdi_write_data(ftdi, greenPack, m);
      usleep(DAB);
      break;

    case 'f':   // twnk8 flash
      nbytes = ftdi_write_data(ftdi, twnk8Pack, m);
      usleep(DAB);
      break;

    case 'g':  // gold flash
      nbytes = ftdi_write_data(ftdi, goldPack, m);
      usleep(DAB);
      break;

    case 'h':   // twnk9 flash
      nbytes = ftdi_write_data(ftdi, twnk9Pack, m);
      usleep(DAB);
      break;

    case 'j':   // tnk10 flash
      nbytes = ftdi_write_data(ftdi, twnk10Pack, m);
      usleep(DAB);
      break;

    case 'k':  // cyan flash
      nbytes = ftdi_write_data(ftdi, cyanPack, m);
      usleep(DAB);
      break;

    case 'l':   // tnk11 flash
      nbytes = ftdi_write_data(ftdi, twnk11Pack, m);
      usleep(DAB);
      break;

    case 'm':  // magenta flash
      nbytes = ftdi_write_data(ftdi, magentaPack, m);
      usleep(DAB);
      break;

    case 'n':  // gold on
      do {
	      nbytes = ftdi_write_data(ftdi, goldPack, m);
	      usleep(DORK);
      } while (getch() != ',');  
      break;

    case 'o':  // white on
      do {
        nbytes = ftdi_write_data(ftdi, whitePack, m);
        usleep(DOT);
      } while (getch() != ',');  
      break;

    case '=':  // new byte setup test
      do {
        nbytes = ftdi_write_data(ftdi, testPack, m);
        if(two_devices == true) {
          nbytes = ftdi_write_data(ftdi_2, testPack_2, m);
        }
        //printf("%ld\n", m);
        usleep(DOT);
      } while (getch() != ',');  
      nbytes = ftdi_write_data(ftdi, dbytePack, m);
      if(two_devices == true) {
        nbytes = ftdi_write_data(ftdi_2, dbytePack, m);
      }
      break;

    case 'p':  // rainbow med
      nbytes = ftdi_write_data(ftdi, rain5Pack, m);
      usleep(DASH);
      nbytes = ftdi_write_data(ftdi, rain6Pack, m);
      usleep(DAB);
      nbytes = ftdi_write_data(ftdi, rain6Pack, m);
      usleep(DASH);
      nbytes = ftdi_write_data(ftdi, rain7Pack, m);
      usleep(DAB);
      nbytes = ftdi_write_data(ftdi, rain7Pack, m);
      usleep(DASH);
      nbytes = ftdi_write_data(ftdi, rain8Pack, m);
      usleep(DAB);
      nbytes = ftdi_write_data(ftdi, rain8Pack, m);
      usleep(DASH);
      nbytes = ftdi_write_data(ftdi, dPack, m);
      usleep(DAB);
      nbytes = ftdi_write_data(ftdi, dPack, m);
      break;

      // 'q' coded below

    case 'r':  // red flash
      nbytes = ftdi_write_data(ftdi, redPack, m);
      usleep(DAB);
      break;

    case 's':  // rainbow short
      nbytes = ftdi_write_data(ftdi, rain1Pack, m);
      usleep(DASH);
      nbytes = ftdi_write_data(ftdi, rain2Pack, m);
      usleep(DASH);
      nbytes = ftdi_write_data(ftdi, rain3Pack, m);
      usleep(DASH);
      nbytes = ftdi_write_data(ftdi, rain4Pack, m);
      usleep(DASH);
      break;

    case 't':  // test           
      do {
        nbytes = ftdi_write_data(ftdi, redPack, m);
        usleep(DASH);
        nbytes = ftdi_write_data(ftdi, greenPack, m);
        usleep(DASH);
        nbytes = ftdi_write_data(ftdi, bluePack, m);
        usleep(DASH);
        nbytes = ftdi_write_data(ftdi, blkPack, m);
        usleep(DASH);
        usleep(DASH);
      } while (getch() != ',');      
      break;

    case 'v':  // red flash
      nbytes = ftdi_write_data(ftdi, orangePack, m);
      usleep(DAB);
      break;


    case 'w':  // white flash
      nbytes = ftdi_write_data(ftdi, whitePack, m);
      usleep(DAB);
      break;

    case 'x':  // christmas solid
      do {
        nbytes = ftdi_write_data(ftdi, X1Pack, m);
        usleep(DROOL);
      } while (getch() != ',');   
      break;

    case 'y':  // yellow flash
      nbytes = ftdi_write_data(ftdi, yellowPack, m);
      usleep(DAB);
      break;

    case 'z':  // slow christmas twinkle
      do {
        nbytes = ftdi_write_data(ftdi, X1Pack, m);
        usleep(DASH);
        usleep(DASH);
        nbytes = ftdi_write_data(ftdi, X2Pack, m);
        usleep(DASH);
        usleep(DASH);
        nbytes = ftdi_write_data(ftdi, X3Pack, m);
        usleep(DASH);
        usleep(DASH);
        nbytes = ftdi_write_data(ftdi, X4Pack, m);
        usleep(DASH);
        usleep(DASH);
      } while (getch() != ',');      
      break;

    case 'a':  //asterion
      do {
        nbytes = ftdi_write_data(ftdi, twnk1Pack, m);
        usleep(DROOL);
        nbytes = ftdi_write_data(ftdi, twnk2Pack, m);
        usleep(DROOL);
        nbytes = ftdi_write_data(ftdi, twnk3Pack, m);
        usleep(DROOL);
        nbytes = ftdi_write_data(ftdi, twnk4Pack, m);
        usleep(DROOL);

        nbytes = ftdi_write_data(ftdi, twnk5Pack, m);
        usleep(DROOL);
        nbytes = ftdi_write_data(ftdi, twnk6Pack, m);
        usleep(DROOL);
        nbytes = ftdi_write_data(ftdi, twnk7Pack, m);
        usleep(DROOL);
        nbytes = ftdi_write_data(ftdi, twnk8Pack, m);
        usleep(DROOL);

        nbytes = ftdi_write_data(ftdi, twnk9Pack, m);
        usleep(DROOL);
        nbytes = ftdi_write_data(ftdi, twnk10Pack, m);
        usleep(DROOL);
        nbytes = ftdi_write_data(ftdi, twnk11Pack, m);
        usleep(DROOL);
        nbytes = ftdi_write_data(ftdi, twnk12Pack, m);
        usleep(DROOL);
      } while (getch() != ','); 
      break;

    case 'q':   // rainbow cycle
      do {
        nbytes = ftdi_write_data(ftdi, rain1Pack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, rain2Pack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, rain3Pack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, rain4Pack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
      } while (getch() != ',');      
      break;

    case '1':   // snowman w/ white
      do {
        nbytes = ftdi_write_data(ftdi, snowman1,  m);
        usleep(SLP);
              rotate13(snowman1);
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, snowman1,  m);
        usleep(SLP);
              rotate13(snowman1);
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
      } while (getch() != ',');      
      break;

    case '2':   // snowman w/ white1
      do {
        nbytes = ftdi_write_data(ftdi, snowman2,  m);
        usleep(SLP);
        rotate13(snowman2);
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, snowman2,  m);
        usleep(SLP);
        rotate13(snowman2);
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
      } while (getch() != ',');      
      break;

    case '3':   // tree1 (gold sparkle, colorguard red)
      do {
        nbytes = ftdi_write_data(ftdi, tree1,     m);
        usleep(SLP);
        rotate13(tree1   );
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, tree1,     m);
        usleep(SLP);
        rotate13(tree1   );
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
      } while (getch() != ',');      
      break;

    case '4':   // tree1 (white sparkle, colorguard red/gold)
      do {
        nbytes = ftdi_write_data(ftdi, tree2,     m);
        usleep(SLP);
        rotate13(tree2   );
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
        nbytes = ftdi_write_data(ftdi, tree2,     m);
        usleep(SLP);
        rotate13(tree2   );
        nbytes = ftdi_write_data(ftdi, dPack, m);
        usleep(SLP);
      } while (getch() != ',');      
      break;

    case '0':  // christmas sparkle
      do {
        nbytes = ftdi_write_data(ftdi, rgPack, m);
        usleep(DASH);
        nbytes = ftdi_write_data(ftdi, grPack, m);
        usleep(DASH);
      } while (getch() != ',');  
      break;

    case '<':   // dimmer code
      printw("getting dimmer...TBA");
      break;

    case '>':   // brighter code
      printw("getting brighter...TBA");
      break;

    case '[':   // fast marqee left
      // load the broadcast array
      for (i=0; i<96; i++) {
	      sorc[i] = igPack[i];
      }
      // loop
      do {
        // store the rollover values
        for (i=0; i<3; i++) {
          temp[i] = sorc[i];
        }
        for (i=0; i<96; i++) {
          if(i<93)
            sorc[i] = sorc[i+3];
          else sorc[i] = temp[i%3];
        }
	      nbytes = ftdi_write_data(ftdi, sorc, m);
        usleep(DAB);
      } while (getch() != ',');  
      break;

    case ']':   // fast marqee right
      for (i=0; i<96; i++) {
	      sorc[i] = igPack[i];
      }

      do {
        for (i=93; i<96; i++) {
          temp[i-93] = sorc[i];
        }
        for (i=95; i>-1; i--) {
          if(i>2)
            sorc[i] = sorc[i-3];
          else sorc[i] = temp[i];
        }
        nbytes = ftdi_write_data(ftdi, sorc, m);
        usleep(DAB);
      } while (getch() != ',');  
      break;

    case '{':   // slow marqee left
      // load the broadcast array
      for (i=0; i<96; i++) {
	      sorc[i] = igPack[i];
      }
      // loop
      do {
        // store the rollover values
        for (i=0; i<3; i++) {
          temp[i] = sorc[i];
        }
        for (i=0; i<96; i++) {
          if(i<93)
            sorc[i] = sorc[i+3];
          else sorc[i] = temp[i%3];
        }
	      nbytes = ftdi_write_data(ftdi, sorc, m);
        usleep(SLOW);
      } while (getch() != ',');  
      break;

    case '}':   // slow marqee right
      for (i=0; i<96; i++) {
	      sorc[i] = igPack[i];
      }

      do {
        for (i=93; i<96; i++) {
          temp[i-93] = sorc[i];
        }
        for (i=95; i>-1; i--) {
          if(i>2)
            sorc[i] = sorc[i-3];
          else sorc[i] = temp[i];
        }
        nbytes = ftdi_write_data(ftdi, sorc, m);
        usleep(SLOW);
      } while (getch() != ',');  
      break;

    default:
      usleep(DAB);
    }
  }
    nbytes = ftdi_write_data(ftdi, dbytePack, m);
   // Draw a space over current character
    move(14,0);
    printw(" ");
    refresh();
  } while (letter != '.');
  
  endwin();   // close curses session
  
  // close ftdi device connection
  if ((ret = ftdi_usb_close(ftdi)) < 0)
    {
      fprintf(stderr, "unable to close ftdi1: %d (%s)\n", ret, ftdi_get_error_string(ftdi));
      return 1;
    }

  ftdi_free(ftdi);
  
  printf("End of program.\n");
  
  return 0;
} // END main

void rotate13 (uint8_t arr[]) {
    // This routine rotates the values in the lower 13 channels (channels 0-12)
    // since the flags are on channels 13 and 14, they are left alone
   uint8_t  r, g, b;
   int i, j, nrot;

   r = arr[0];
   g = arr[1];
   b = arr[2];

   nrot = 13;
   for(i = 3; i < nrot*3; i++) {
      j = i + 48;
      arr[i-3] = arr[i];
      arr[j-3] = arr[j];
     } // for i
 
   arr[nrot*3] = r;
   arr[nrot*3+1] = g;
   arr[nrot*3+2] = b;

  } // END rotate12


static size_t getEncodedBufferSize(size_t sourceSize) {
  size_t s;
  s = sourceSize + sourceSize / 254 + 1;
  printf("buffer size is : %zd.\n", s);
  return s;
}

bool find_ftdi()  {

}

uint8_t convert_blue(int color) 
{
  int picked = 0;
  uint8_t color_options[4] = {0, 85, 170, 255};
  for( int i = 0; i < 4; i++) {
    if(abs(color_options[i] - color) < 43)
      picked = i;
  }
  switch(picked)
  {
    case 0:
      return 0b00000000;
      break;
    case 1:
      return 0b00000001;
      break;
    case 2:
      return 0b00000010;
      break;
    case 3:
      return 0b00000011;
      break;
  }
}

uint8_t convert_green(int color)
{
  int picked = 0;
  uint8_t color_options[8] = {0, 37, 74, 111, 148, 185, 222, 255};
  for (int i = 0; i < 8; i++) {
    if(abs(color_options[i] - color) < 19)
      picked = i;
  }
  switch(picked)
  {
    case 0:
      return 0b00000000;
      break;
    case 1:
      return 0b00000100;
      break;
    case 2:
      return 0b00001000;
      break;
    case 3:
      return 0b00001100;
      break;
    case 4:
      return 0b00010000;
      break;
    case 5:
      return 0b00010100;
      break;
    case 6:
      return 0b00011000;
      break;
    case 7:
      return 0b00011100;
      break;
  }
}

uint8_t convert_red(int color)
{
  int picked = 0;
  uint8_t color_options[8] = {0, 37, 74, 111, 148, 185, 222, 255};
  for (int i = 0; i < 8; i++) {
    if(abs(color_options[i] - color) < 19)
      picked = i;
  }
  switch(picked)
  {
    case 0:
      return 0b00000000;
      break;
    case 1:
      return 0b00100000;
      break;
    case 2:
      return 0b01000000;
      break;
    case 3:
      return 0b01100000;
      break;
    case 4:
      return 0b10000000;
      break;
    case 5:
      return 0b10100000;
      break;
    case 6:
      return 0b11000000;
      break;
    case 7:
      return 0b11100000;
      break;
  }
}

//glasses_information will contain an entire files worth of text.
uint8_t create_patterns(char *glasses_information, uint8_t ***test_converted_ht13, int **time_converted_ht13, int z)  {
  for (int i = 0; i < 108; i++) {
    test_converted_ht13[z][0][i] = 0;
  }
  uint8_t converted_red = 0;
  uint8_t converted_green = 0;
  uint8_t converted_blue = 0;
  uint8_t rgb_color = 0;
  int current_pattern = 0;
  for (int i = 0; i < strlen(glasses_information); i++)
  {
    //find the address
    int address = 0;
    if((47 < glasses_information[i]) && (glasses_information[i] < 58))  {
      address = glasses_information[i] - 48;
      while((47 < glasses_information[i+1]) && (glasses_information[i+1] < 58))  {
        address = (address * 10) + (glasses_information[i+1] - 48);
        i++;
        if((47 < glasses_information[i+1]) && (glasses_information[i+1] < 58))  {
          address = (address * 10) + (glasses_information[i+1] - 48);
          i++;
        }
    
      }
      if(glasses_information[i+1] == 41)  {
        time_converted_ht13[z][current_pattern] = address;
        //printw("\n %d \n", address);
        //printw("\n %d \n", time_converted_ht13[0][current_pattern]);
        current_pattern++;
        time_converted_ht13[z][current_pattern + 1] = -1;
        for (int p = 0; p < 108; p++) {
          test_converted_ht13[z][current_pattern][p] = 0;
        }
      }
      else  {
        //figure out what color
        int color = 0;
        i = i + 2;
        //Red coloring is found by checking number until seperated by a "["
        converted_red = 0;
        converted_green = 0;
        converted_blue = 0;
        rgb_color = 0;
        while(glasses_information[i] != 91) {
          color = (color * 10) + (glasses_information[i] - 48);
          i++;
        }
        converted_red = convert_red(color);
        color = 0;
        i++;
        while(glasses_information[i] != 91) {
          color = (color * 10) + (glasses_information[i] - 48);
          i++;
        }
        converted_green = convert_green(color);
        color = 0;
        i++;
        while(glasses_information[i] != 124)  {
          color = (color * 10) + (glasses_information[i] - 48);
          i++;
        }
        converted_blue = convert_blue(color);
        color = 0;
        rgb_color = converted_red + converted_green + converted_blue;
        //use a function to condense this result into three bits to find red

        test_converted_ht13[z][current_pattern][address] = rgb_color;
        color = 0;
      }
    }
    address = 0;
  }
}

// when returning 1, scandir will put this dirent into the list
static int parse_ext(const struct dirent *dir)
{
  if(!dir)
    return 0;

  if(dir->d_type == DT_REG) {
    const char *ext = strrchr(dir->d_name,'.');
    if((!ext) || ext == dir->d_name)
      return 0;
    else  {
      if(strcmp(ext, ".ht13") == 0)
      return 1;
    }
  }
  return 0;
}